/-
Copyright (c) 2014 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura

notation, basic datatypes and type classes
-/
import Mathlib

universe u v w

/-- The kernel definitional equality test (t =?= s) has special support for id_delta applications.
It implements the following rules

   1)   (id_delta t) =?= t
   2)   t =?= (id_delta t)
   3)   (id_delta t) =?= s  IF (unfold_of t) =?= s
   4)   t =?= id_delta s    IF t =?= (unfold_of s)

This is mechanism for controlling the delta reduction (aka unfolding) used in the kernel.

We use id_delta applications to address performance problems when type checking
lemmas generated by the equation compiler.
-/
@[inline]
def idDelta {α : Sort u} (a : α) : α :=
  a

/-
  id_rhs is an auxiliary declaration used in the equation compiler to address performance
  issues when proving equational lemmas. The equation compiler uses it as a marker.
-/
abbrev idRhs (α : Sort u) (a : α) : α :=
  a

@[matchPattern]
abbrev Unit.star : Unit :=
  PUnit.unit

theorem And.elim_left {a b : Prop} (h : And a b) : a :=
  h.1

theorem And.elim_right {a b : Prop} (h : And a b) : b :=
  h.2

-- eq basic support
-- attribute [refl] Eq.refl -- TODO

def Prod.mk.injArrow {α : Type u} {β : Type v} {x₁ : α} {y₁ : β} {x₂ : α} {y₂ : β} :
    (x₁, y₁) = (x₂, y₂) → ∀ ⦃P : Sort w⦄, (x₁ = x₂ → y₁ = y₂ → P) → P := fun h₁ _ h₂ => Prod.noConfusion h₁ h₂

def PProd.mk.injArrow {α : Type u} {β : Type v} {x₁ : α} {y₁ : β} {x₂ : α} {y₂ : β} :
    (x₁, y₁) = (x₂, y₂) → ∀ ⦃P : Sort w⦄, (x₁ = x₂ → y₁ = y₂ → P) → P := fun h₁ _ h₂ => Prod.noConfusion h₁ h₂

class HasAndthen (α : Type u) (β : Type v) (σ : outParam <| Type w) where
  andthen : α → β → σ

export HasAndthen (andthen)

export Append (append)

@[reducible]
def Ge {α : Type u} [LE α] (a b : α) : Prop :=
  LE.le b a

@[reducible]
def Gt {α : Type u} [LT α] (a b : α) : Prop :=
  LT.lt b a

def bit0 {α : Type u} [s : Add α] (a : α) : α :=
  a + a

def bit1 {α : Type u} [s₁ : One α] [s₂ : Add α] (a : α) : α :=
  bit0 a + 1

-- Combinator calculus
namespace Combinator

universe u₁ u₂ u₃

def i {α : Type u₁} (a : α) :=
  a

def k {α : Type u₁} {β : Type u₂} (a : α) (b : β) :=
  a

def s {α : Type u₁} {β : Type u₂} {γ : Type u₃} (x : α → β → γ) (y : α → β) (z : α) :=
  x z (y z)

end Combinator

