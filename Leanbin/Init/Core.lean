/-
Copyright (c) 2014 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura

notation, basic datatypes and type classes
-/
import Mathlib

universe u v w

/-- The kernel definitional equality test (t =?= s) has special support for id_delta applications.
It implements the following rules

   1)   (id_delta t) =?= t
   2)   t =?= (id_delta t)
   3)   (id_delta t) =?= s  IF (unfold_of t) =?= s
   4)   t =?= id_delta s    IF t =?= (unfold_of s)

This is mechanism for controlling the delta reduction (aka unfolding) used in the kernel.

We use id_delta applications to address performance problems when type checking
lemmas generated by the equation compiler.
-/
@[inline]
def idDelta {α : Sort u} (a : α) : α :=
  a

/-
  id_rhs is an auxiliary declaration used in the equation compiler to address performance
  issues when proving equational lemmas. The equation compiler uses it as a marker.
-/
abbrev idRhs (α : Sort u) (a : α) : α :=
  a

@[matchPattern]
abbrev Unit.star : Unit :=
  PUnit.unit

theorem And.elim_left {a b : Prop} (h : And a b) : a :=
  h.1

theorem And.elim_right {a b : Prop} (h : And a b) : b :=
  h.2

-- eq basic support
-- attribute [refl] Eq.refl -- TODO

def Prod.mk.injArrow {α : Type u} {β : Type v} {x₁ : α} {y₁ : β} {x₂ : α} {y₂ : β} :
    (x₁, y₁) = (x₂, y₂) → ∀ ⦃P : Sort w⦄, (x₁ = x₂ → y₁ = y₂ → P) → P := fun h₁ _ h₂ => Prod.noConfusion h₁ h₂

def PProd.mk.injArrow {α : Type u} {β : Type v} {x₁ : α} {y₁ : β} {x₂ : α} {y₂ : β} :
    (x₁, y₁) = (x₂, y₂) → ∀ ⦃P : Sort w⦄, (x₁ = x₂ → y₁ = y₂ → P) → P := fun h₁ _ h₂ => Prod.noConfusion h₁ h₂

class HasAndthen (α : Type u) (β : Type v) (σ : outParam <| Type w) where
  andthen : α → β → σ

class HasSsubset (α : Type u) where
  Ssubset : α → α → Prop

class HasInsert (α : outParam <| Type u) (γ : Type v) where
  insert : α → γ → γ

class HasSingleton (α : outParam <| Type u) (β : Type v) where
  singleton : α → β

-- Type class used to implement the notation { a ∈ c | p a }
class HasSep (α : outParam <| Type u) (γ : Type v) where
  sep : (α → Prop) → γ → γ

export HasAndthen (andthen)

-- mathport name: «expr ⊂ »
infixl:50
  " ⊂ " =>-- Note this is different to `|`.
  HasSsubset.Ssubset

export Append (append)

@[reducible]
def Ge {α : Type u} [LE α] (a b : α) : Prop :=
  LE.le b a

@[reducible]
def Gt {α : Type u} [LT α] (a b : α) : Prop :=
  LT.lt b a

@[reducible]
def Superset {α : Type u} [Subset α] (a b : α) : Prop :=
  Subset.subset b a

@[reducible]
def Ssuperset {α : Type u} [HasSsubset α] (a b : α) : Prop :=
  HasSsubset.Ssubset b a

-- mathport name: «expr ⊇ »
infixl:50 " ⊇ " => Superset

-- mathport name: «expr ⊃ »
infixl:50 " ⊃ " => Ssuperset

def bit0 {α : Type u} [s : Add α] (a : α) : α :=
  a + a

def bit1 {α : Type u} [s₁ : One α] [s₂ : Add α] (a : α) : α :=
  bit0 a + 1

export HasInsert (insert)

-- TODO
-- class IsLawfulSingleton (α : Type u) (β : Type v) [EmptyCollection β] [HasInsert α β] [HasSingleton α β] : Prop where
--   insert_emptyc_eq : ∀ x : α, (insert x ∅ : β) = {x}

export HasSingleton (singleton)

-- export IsLawfulSingleton (insert_emptyc_eq) -- TODO

-- attribute [simp] insert_emptyc_eq -- TODO

-- Combinator calculus
namespace Combinator

universe u₁ u₂ u₃

def i {α : Type u₁} (a : α) :=
  a

def k {α : Type u₁} {β : Type u₂} (a : α) (b : β) :=
  a

def s {α : Type u₁} {β : Type u₂} {γ : Type u₃} (x : α → β → γ) (y : α → β) (z : α) :=
  x z (y z)

end Combinator

