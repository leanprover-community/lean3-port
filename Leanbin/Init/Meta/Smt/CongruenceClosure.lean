/-
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/
prelude
import Init.Meta.InteractiveBase
import Init.Meta.Tactic
import Init.Meta.SetGetOptionTactics

#align_import init.meta.smt.congruence_closure from "leanprover-community/lean"@"9eae65f7144bcc692858b9dadf2e48181f4270b9"

#print Mathlib.Tactic.CC.CCConfig /-
structure Mathlib.Tactic.CC.CCConfig where
  -- If tt, congruence closure will treat implicit instance arguments as constants.
  ignoreInstances : Bool := true
  -- If tt, congruence closure modulo AC.
  ac : Bool := true
  /- If ho_fns is (some fns), then full (and more expensive) support for higher-order functions is
     *only* considered for the functions in fns and local functions. The performance overhead is described in the paper
     "Congruence Closure in Intensional Type Theory". If ho_fns is none, then full support is provided
     for *all* constants. -/
  hoFns : Option (List Name) := none
  -- If true, then use excluded middle
  em : Bool := true
#align cc_config Mathlib.Tactic.CC.CCConfig
-/

#print Mathlib.Tactic.CC.CCState /-
/-- Congruence closure state.
This may be considered to be a set of expressions and an equivalence class over this set.
The equivalence class is generated by the equational rules that are added to the cc_state and congruence,
that is, if `a = b` then `f(a) = f(b)` and so on.
 -/
unsafe axiom Mathlib.Tactic.CC.CCState : Type
#align cc_state Mathlib.Tactic.CC.CCState
-/

unsafe axiom cc_state.mk_core : Mathlib.Tactic.CC.CCConfig → Mathlib.Tactic.CC.CCState
#align cc_state.mk_core cc_state.mk_core

/-- Create a congruence closure state object using the hypotheses in the current goal. -/
unsafe axiom cc_state.mk_using_hs_core :
    Mathlib.Tactic.CC.CCConfig → tactic Mathlib.Tactic.CC.CCState
#align cc_state.mk_using_hs_core cc_state.mk_using_hs_core

#print Mathlib.Tactic.CC.CCState.next /-
/-- Get the next element in the equivalence class.
Note that if the given expr e is not in the graph then it will just return e. -/
unsafe axiom Mathlib.Tactic.CC.CCState.next : Mathlib.Tactic.CC.CCState → expr → expr
#align cc_state.next Mathlib.Tactic.CC.CCState.next
-/

/-- Returns the root expression for each equivalence class in the graph.
If the bool argument is set to true then it only returns roots of non-singleton classes. -/
unsafe axiom cc_state.roots_core : Mathlib.Tactic.CC.CCState → Bool → List expr
#align cc_state.roots_core cc_state.roots_core

#print Mathlib.Tactic.CC.CCState.root /-
/-- Get the root representative of the given expression. -/
unsafe axiom Mathlib.Tactic.CC.CCState.root : Mathlib.Tactic.CC.CCState → expr → expr
#align cc_state.root Mathlib.Tactic.CC.CCState.root
-/

#print Mathlib.Tactic.CC.CCState.mt /-
/--
"Modification Time". The field m_mt is used to implement the mod-time optimization introduce by the Simplify theorem prover.
The basic idea is to introduce a counter gmt that records the number of heuristic instantiation that have
occurred in the current branch. It is incremented after each round of heuristic instantiation.
The field m_mt records the last time any proper descendant of of thie entry was involved in a merge. -/
unsafe axiom Mathlib.Tactic.CC.CCState.mt : Mathlib.Tactic.CC.CCState → expr → Nat
#align cc_state.mt Mathlib.Tactic.CC.CCState.mt
-/

#print Mathlib.Tactic.CC.CCState.gmt /-
/-- "Global Modification Time". gmt is a number stored on the cc_state,
it is compared with the modification time of a cc_entry in e-matching. See `cc_state.mt`. -/
unsafe axiom Mathlib.Tactic.CC.CCState.gmt : Mathlib.Tactic.CC.CCState → Nat
#align cc_state.gmt Mathlib.Tactic.CC.CCState.gmt
-/

/-- Increment the Global Modification time. -/
unsafe axiom cc_state.inc_gmt : Mathlib.Tactic.CC.CCState → Mathlib.Tactic.CC.CCState
#align cc_state.inc_gmt cc_state.inc_gmt

#print Mathlib.Tactic.CC.CCState.isCgRoot /-
/-- Check if `e` is the root of the congruence class. -/
unsafe axiom Mathlib.Tactic.CC.CCState.isCgRoot : Mathlib.Tactic.CC.CCState → expr → Bool
#align cc_state.is_cg_root Mathlib.Tactic.CC.CCState.isCgRoot
-/

#print Mathlib.Tactic.CC.CCState.ppEqc /-
/-- Pretty print the entry associated with the given expression. -/
unsafe axiom Mathlib.Tactic.CC.CCState.ppEqc : Mathlib.Tactic.CC.CCState → expr → tactic format
#align cc_state.pp_eqc Mathlib.Tactic.CC.CCState.ppEqc
-/

#print Mathlib.Tactic.CC.CCState.ppEqcs /-
/-- Pretty print the entire cc graph.
If the bool argument is set to true then singleton equivalence classes will be omitted. -/
unsafe axiom Mathlib.Tactic.CC.CCState.ppEqcs : Mathlib.Tactic.CC.CCState → Bool → tactic format
#align cc_state.pp_core Mathlib.Tactic.CC.CCState.ppEqcs
-/

/-- Add the given expression to the graph. -/
unsafe axiom cc_state.internalize :
    Mathlib.Tactic.CC.CCState → expr → tactic Mathlib.Tactic.CC.CCState
#align cc_state.internalize cc_state.internalize

/-- Add the given proof term as a new rule.
The proof term p must be an `eq _ _`, `heq _ _`, `iff _ _`, or a negation of these. -/
unsafe axiom cc_state.add : Mathlib.Tactic.CC.CCState → expr → tactic Mathlib.Tactic.CC.CCState
#align cc_state.add cc_state.add

/-- Check whether two expressions are in the same equivalence class. -/
unsafe axiom cc_state.is_eqv : Mathlib.Tactic.CC.CCState → expr → expr → tactic Bool
#align cc_state.is_eqv cc_state.is_eqv

/-- Check whether two expressions are not in the same equivalence class. -/
unsafe axiom cc_state.is_not_eqv : Mathlib.Tactic.CC.CCState → expr → expr → tactic Bool
#align cc_state.is_not_eqv cc_state.is_not_eqv

/-- Returns a proof term that the given terms are equivalent in the given cc_state-/
unsafe axiom cc_state.eqv_proof : Mathlib.Tactic.CC.CCState → expr → expr → tactic expr
#align cc_state.eqv_proof cc_state.eqv_proof

#print Mathlib.Tactic.CC.CCState.inconsistent /-
/--
Returns true if the cc_state is inconsistent. For example if it had both `a = b` and `a ≠ b` in it.-/
unsafe axiom Mathlib.Tactic.CC.CCState.inconsistent : Mathlib.Tactic.CC.CCState → Bool
#align cc_state.inconsistent Mathlib.Tactic.CC.CCState.inconsistent
-/

/-- `proof_for cc e` constructs a proof for e if it is equivalent to true in cc_state -/
unsafe axiom cc_state.proof_for : Mathlib.Tactic.CC.CCState → expr → tactic expr
#align cc_state.proof_for cc_state.proof_for

/-- `refutation_for cc e` constructs a proof for `not e` if it is equivalent to false in cc_state -/
unsafe axiom cc_state.refutation_for : Mathlib.Tactic.CC.CCState → expr → tactic expr
#align cc_state.refutation_for cc_state.refutation_for

/-- If the given state is inconsistent, return a proof for false. Otherwise fail. -/
unsafe axiom cc_state.proof_for_false : Mathlib.Tactic.CC.CCState → tactic expr
#align cc_state.proof_for_false cc_state.proof_for_false

namespace Mathlib.Tactic.CC.CCState

unsafe def mk : Mathlib.Tactic.CC.CCState :=
  cc_state.mk_core { }
#align cc_state.mk cc_state.mk

unsafe def mk_using_hs : tactic Mathlib.Tactic.CC.CCState :=
  cc_state.mk_using_hs_core { }
#align cc_state.mk_using_hs cc_state.mk_using_hs

unsafe def roots (s : Mathlib.Tactic.CC.CCState) : List expr :=
  cc_state.roots_core s true
#align cc_state.roots cc_state.roots

unsafe instance : has_to_tactic_format Mathlib.Tactic.CC.CCState :=
  ⟨fun s => Mathlib.Tactic.CC.CCState.ppEqcs s true⟩

unsafe def eqc_of_core (s : Mathlib.Tactic.CC.CCState) : expr → expr → List expr → List expr
  | e, f, r =>
    let n := s.next e
    if n = f then e :: r else eqc_of_core n f (e :: r)
#align cc_state.eqc_of_core cc_state.eqc_of_core

unsafe def eqc_of (s : Mathlib.Tactic.CC.CCState) (e : expr) : List expr :=
  s.eqc_of_core e e []
#align cc_state.eqc_of cc_state.eqc_of

#print Mathlib.Tactic.CC.CCState.inSingletonEqc /-
unsafe def Mathlib.Tactic.CC.CCState.inSingletonEqc (s : Mathlib.Tactic.CC.CCState) (e : expr) :
    Bool :=
  s.next e = e
#align cc_state.in_singlenton_eqc Mathlib.Tactic.CC.CCState.inSingletonEqc
-/

unsafe def eqc_size (s : Mathlib.Tactic.CC.CCState) (e : expr) : Nat :=
  (s.eqc_of e).length
#align cc_state.eqc_size cc_state.eqc_size

unsafe def fold_eqc_core {α} (s : Mathlib.Tactic.CC.CCState) (f : α → expr → α) (first : expr) :
    expr → α → α
  | c, a =>
    let new_a := f a c
    let next := s.next c
    if next == first then new_a else fold_eqc_core next new_a
#align cc_state.fold_eqc_core cc_state.fold_eqc_core

unsafe def fold_eqc {α} (s : Mathlib.Tactic.CC.CCState) (e : expr) (a : α) (f : α → expr → α) : α :=
  fold_eqc_core s f e e a
#align cc_state.fold_eqc cc_state.fold_eqc

unsafe def mfold_eqc {α} {m : Type → Type} [Monad m] (s : Mathlib.Tactic.CC.CCState) (e : expr)
    (a : α) (f : α → expr → m α) : m α :=
  fold_eqc s e (return a) fun act e => do
    let a ← act
    f a e
#align cc_state.mfold_eqc cc_state.mfold_eqc

end Mathlib.Tactic.CC.CCState

open Tactic

unsafe def tactic.cc_core (cfg : Mathlib.Tactic.CC.CCConfig) : tactic Unit := do
  intros
  let s ← cc_state.mk_using_hs_core cfg
  let t ← target
  let s ← s.internalize t
  if s then do
      let pr ← s
      mk_app `false.elim [t, pr] >>= exact
    else do
      let tr ← return <| expr.const `true []
      let b ← s t tr
      if b then do
          let pr ← s t tr
          mk_app `of_eq_true [pr] >>= exact
        else do
          let dbg ← get_bool_option `trace.cc.failure ff
          if dbg then do
              let ccf ← pp s
              fail
                  f! "cc tactic failed, equivalence classes: 
                    {ccf}"
            else do
              fail "cc tactic failed"
#align tactic.cc_core tactic.cc_core

unsafe def tactic.cc : tactic Unit :=
  tactic.cc_core { }
#align tactic.cc tactic.cc

unsafe def tactic.cc_dbg_core (cfg : Mathlib.Tactic.CC.CCConfig) : tactic Unit :=
  save_options <| set_bool_option `trace.cc.failure true >> tactic.cc_core cfg
#align tactic.cc_dbg_core tactic.cc_dbg_core

unsafe def tactic.cc_dbg : tactic Unit :=
  tactic.cc_dbg_core { }
#align tactic.cc_dbg tactic.cc_dbg

unsafe def tactic.ac_refl : tactic Unit := do
  let (lhs, rhs) ← target >>= match_eq
  let s ← return <| cc_state.mk
  let s ← s.internalize lhs
  let s ← s.internalize rhs
  let b ← s.is_eqv lhs rhs
  if b then do
      s lhs rhs >>= exact
    else do
      fail "ac_refl failed"
#align tactic.ac_refl tactic.ac_refl

