/-
Copyright (c) 2016 Microsoft Corporation. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Leonardo de Moura
-/
prelude
import Init.Meta.InteractiveBase
import Init.Meta.Tactic
import Init.Meta.SetGetOptionTactics

#align_import init.meta.smt.congruence_closure from "leanprover-community/lean"@"9eae65f7144bcc692858b9dadf2e48181f4270b9"

#print Mathlib.Tactic.CC.CCConfig /-
structure Mathlib.Tactic.CC.CCConfig where
  -- If tt, congruence closure will treat implicit instance arguments as constants.
  ignoreInstances : Bool := true
  -- If tt, congruence closure modulo AC.
  ac : Bool := true
  /- If ho_fns is (some fns), then full (and more expensive) support for higher-order functions is
     *only* considered for the functions in fns and local functions. The performance overhead is described in the paper
     "Congruence Closure in Intensional Type Theory". If ho_fns is none, then full support is provided
     for *all* constants. -/
  hoFns : Option (List Name) := none
  -- If true, then use excluded middle
  em : Bool := true
#align cc_config Mathlib.Tactic.CC.CCConfig
-/

#print Mathlib.Tactic.CC.CCState /-
/-- Congruence closure state.
This may be considered to be a set of expressions and an equivalence class over this set.
The equivalence class is generated by the equational rules that are added to the cc_state and congruence,
that is, if `a = b` then `f(a) = f(b)` and so on.
 -/
unsafe axiom Mathlib.Tactic.CC.CCState : Type
#align cc_state Mathlib.Tactic.CC.CCState
-/

#print Mathlib.Tactic.CC.CCState.mkCore /-
unsafe axiom Mathlib.Tactic.CC.CCState.mkCore :
    Mathlib.Tactic.CC.CCConfig → Mathlib.Tactic.CC.CCState
#align cc_state.mk_core Mathlib.Tactic.CC.CCState.mkCore
-/

#print Mathlib.Tactic.CC.CCState.mkUsingHsCore /-
/-- Create a congruence closure state object using the hypotheses in the current goal. -/
unsafe axiom Mathlib.Tactic.CC.CCState.mkUsingHsCore :
    Mathlib.Tactic.CC.CCConfig → tactic Mathlib.Tactic.CC.CCState
#align cc_state.mk_using_hs_core Mathlib.Tactic.CC.CCState.mkUsingHsCore
-/

#print Mathlib.Tactic.CC.CCState.next /-
/-- Get the next element in the equivalence class.
Note that if the given expr e is not in the graph then it will just return e. -/
unsafe axiom Mathlib.Tactic.CC.CCState.next : Mathlib.Tactic.CC.CCState → expr → expr
#align cc_state.next Mathlib.Tactic.CC.CCState.next
-/

#print Mathlib.Tactic.CC.CCState.rootsCore /-
/-- Returns the root expression for each equivalence class in the graph.
If the bool argument is set to true then it only returns roots of non-singleton classes. -/
unsafe axiom Mathlib.Tactic.CC.CCState.rootsCore : Mathlib.Tactic.CC.CCState → Bool → List expr
#align cc_state.roots_core Mathlib.Tactic.CC.CCState.rootsCore
-/

#print Mathlib.Tactic.CC.CCState.root /-
/-- Get the root representative of the given expression. -/
unsafe axiom Mathlib.Tactic.CC.CCState.root : Mathlib.Tactic.CC.CCState → expr → expr
#align cc_state.root Mathlib.Tactic.CC.CCState.root
-/

#print Mathlib.Tactic.CC.CCState.mt /-
/--
"Modification Time". The field m_mt is used to implement the mod-time optimization introduce by the Simplify theorem prover.
The basic idea is to introduce a counter gmt that records the number of heuristic instantiation that have
occurred in the current branch. It is incremented after each round of heuristic instantiation.
The field m_mt records the last time any proper descendant of of thie entry was involved in a merge. -/
unsafe axiom Mathlib.Tactic.CC.CCState.mt : Mathlib.Tactic.CC.CCState → expr → Nat
#align cc_state.mt Mathlib.Tactic.CC.CCState.mt
-/

#print Mathlib.Tactic.CC.CCState.gmt /-
/-- "Global Modification Time". gmt is a number stored on the cc_state,
it is compared with the modification time of a cc_entry in e-matching. See `cc_state.mt`. -/
unsafe axiom Mathlib.Tactic.CC.CCState.gmt : Mathlib.Tactic.CC.CCState → Nat
#align cc_state.gmt Mathlib.Tactic.CC.CCState.gmt
-/

#print Mathlib.Tactic.CC.CCState.incGMT /-
/-- Increment the Global Modification time. -/
unsafe axiom Mathlib.Tactic.CC.CCState.incGMT :
    Mathlib.Tactic.CC.CCState → Mathlib.Tactic.CC.CCState
#align cc_state.inc_gmt Mathlib.Tactic.CC.CCState.incGMT
-/

#print Mathlib.Tactic.CC.CCState.isCgRoot /-
/-- Check if `e` is the root of the congruence class. -/
unsafe axiom Mathlib.Tactic.CC.CCState.isCgRoot : Mathlib.Tactic.CC.CCState → expr → Bool
#align cc_state.is_cg_root Mathlib.Tactic.CC.CCState.isCgRoot
-/

#print Mathlib.Tactic.CC.CCState.ppEqc /-
/-- Pretty print the entry associated with the given expression. -/
unsafe axiom Mathlib.Tactic.CC.CCState.ppEqc : Mathlib.Tactic.CC.CCState → expr → tactic format
#align cc_state.pp_eqc Mathlib.Tactic.CC.CCState.ppEqc
-/

#print Mathlib.Tactic.CC.CCState.ppEqcs /-
/-- Pretty print the entire cc graph.
If the bool argument is set to true then singleton equivalence classes will be omitted. -/
unsafe axiom Mathlib.Tactic.CC.CCState.ppEqcs : Mathlib.Tactic.CC.CCState → Bool → tactic format
#align cc_state.pp_core Mathlib.Tactic.CC.CCState.ppEqcs
-/

#print Mathlib.Tactic.CC.CCState.internalize /-
/-- Add the given expression to the graph. -/
unsafe axiom Mathlib.Tactic.CC.CCState.internalize :
    Mathlib.Tactic.CC.CCState → expr → tactic Mathlib.Tactic.CC.CCState
#align cc_state.internalize Mathlib.Tactic.CC.CCState.internalize
-/

#print Mathlib.Tactic.CC.CCState.add /-
/-- Add the given proof term as a new rule.
The proof term p must be an `eq _ _`, `heq _ _`, `iff _ _`, or a negation of these. -/
unsafe axiom Mathlib.Tactic.CC.CCState.add :
    Mathlib.Tactic.CC.CCState → expr → tactic Mathlib.Tactic.CC.CCState
#align cc_state.add Mathlib.Tactic.CC.CCState.add
-/

#print Mathlib.Tactic.CC.CCState.isEqv /-
/-- Check whether two expressions are in the same equivalence class. -/
unsafe axiom Mathlib.Tactic.CC.CCState.isEqv : Mathlib.Tactic.CC.CCState → expr → expr → tactic Bool
#align cc_state.is_eqv Mathlib.Tactic.CC.CCState.isEqv
-/

#print Mathlib.Tactic.CC.CCState.isNotEqv /-
/-- Check whether two expressions are not in the same equivalence class. -/
unsafe axiom Mathlib.Tactic.CC.CCState.isNotEqv :
    Mathlib.Tactic.CC.CCState → expr → expr → tactic Bool
#align cc_state.is_not_eqv Mathlib.Tactic.CC.CCState.isNotEqv
-/

#print Mathlib.Tactic.CC.CCState.eqvProof /-
/-- Returns a proof term that the given terms are equivalent in the given cc_state-/
unsafe axiom Mathlib.Tactic.CC.CCState.eqvProof :
    Mathlib.Tactic.CC.CCState → expr → expr → tactic expr
#align cc_state.eqv_proof Mathlib.Tactic.CC.CCState.eqvProof
-/

#print Mathlib.Tactic.CC.CCState.inconsistent /-
/--
Returns true if the cc_state is inconsistent. For example if it had both `a = b` and `a ≠ b` in it.-/
unsafe axiom Mathlib.Tactic.CC.CCState.inconsistent : Mathlib.Tactic.CC.CCState → Bool
#align cc_state.inconsistent Mathlib.Tactic.CC.CCState.inconsistent
-/

#print Mathlib.Tactic.CC.CCState.proofFor /-
/-- `proof_for cc e` constructs a proof for e if it is equivalent to true in cc_state -/
unsafe axiom Mathlib.Tactic.CC.CCState.proofFor : Mathlib.Tactic.CC.CCState → expr → tactic expr
#align cc_state.proof_for Mathlib.Tactic.CC.CCState.proofFor
-/

#print Mathlib.Tactic.CC.CCState.refutationFor /-
/-- `refutation_for cc e` constructs a proof for `not e` if it is equivalent to false in cc_state -/
unsafe axiom Mathlib.Tactic.CC.CCState.refutationFor :
    Mathlib.Tactic.CC.CCState → expr → tactic expr
#align cc_state.refutation_for Mathlib.Tactic.CC.CCState.refutationFor
-/

#print Mathlib.Tactic.CC.CCState.proofForFalse /-
/-- If the given state is inconsistent, return a proof for false. Otherwise fail. -/
unsafe axiom Mathlib.Tactic.CC.CCState.proofForFalse : Mathlib.Tactic.CC.CCState → tactic expr
#align cc_state.proof_for_false Mathlib.Tactic.CC.CCState.proofForFalse
-/

namespace Mathlib.Tactic.CC.CCState

#print Mathlib.Tactic.CC.CCState.mk /-
unsafe def Mathlib.Tactic.CC.CCState.mk : Mathlib.Tactic.CC.CCState :=
  Mathlib.Tactic.CC.CCState.mkCore { }
#align cc_state.mk Mathlib.Tactic.CC.CCState.mk
-/

#print Mathlib.Tactic.CC.CCState.mkUsingHs /-
unsafe def Mathlib.Tactic.CC.CCState.mkUsingHs : tactic Mathlib.Tactic.CC.CCState :=
  Mathlib.Tactic.CC.CCState.mkUsingHsCore { }
#align cc_state.mk_using_hs Mathlib.Tactic.CC.CCState.mkUsingHs
-/

#print Mathlib.Tactic.CC.CCState.roots /-
unsafe def Mathlib.Tactic.CC.CCState.roots (s : Mathlib.Tactic.CC.CCState) : List expr :=
  Mathlib.Tactic.CC.CCState.rootsCore s true
#align cc_state.roots Mathlib.Tactic.CC.CCState.roots
-/

unsafe instance : has_to_tactic_format Mathlib.Tactic.CC.CCState :=
  ⟨fun s => Mathlib.Tactic.CC.CCState.ppEqcs s true⟩

#print Mathlib.Tactic.CC.CCState.eqcOfCore /-
unsafe def Mathlib.Tactic.CC.CCState.eqcOfCore (s : Mathlib.Tactic.CC.CCState) :
    expr → expr → List expr → List expr
  | e, f, r =>
    let n := s.next e
    if n = f then e :: r else eqc_of_core n f (e :: r)
#align cc_state.eqc_of_core Mathlib.Tactic.CC.CCState.eqcOfCore
-/

#print Mathlib.Tactic.CC.CCState.eqcOf /-
unsafe def Mathlib.Tactic.CC.CCState.eqcOf (s : Mathlib.Tactic.CC.CCState) (e : expr) : List expr :=
  s.eqc_of_core e e []
#align cc_state.eqc_of Mathlib.Tactic.CC.CCState.eqcOf
-/

#print Mathlib.Tactic.CC.CCState.inSingletonEqc /-
unsafe def Mathlib.Tactic.CC.CCState.inSingletonEqc (s : Mathlib.Tactic.CC.CCState) (e : expr) :
    Bool :=
  s.next e = e
#align cc_state.in_singlenton_eqc Mathlib.Tactic.CC.CCState.inSingletonEqc
-/

#print Mathlib.Tactic.CC.CCState.eqcSize /-
unsafe def Mathlib.Tactic.CC.CCState.eqcSize (s : Mathlib.Tactic.CC.CCState) (e : expr) : Nat :=
  (s.eqc_of e).length
#align cc_state.eqc_size Mathlib.Tactic.CC.CCState.eqcSize
-/

#print Mathlib.Tactic.CC.CCState.foldEqcCore /-
unsafe def Mathlib.Tactic.CC.CCState.foldEqcCore {α} (s : Mathlib.Tactic.CC.CCState)
    (f : α → expr → α) (first : expr) : expr → α → α
  | c, a =>
    let new_a := f a c
    let next := s.next c
    if next == first then new_a else fold_eqc_core next new_a
#align cc_state.fold_eqc_core Mathlib.Tactic.CC.CCState.foldEqcCore
-/

#print Mathlib.Tactic.CC.CCState.foldEqc /-
unsafe def Mathlib.Tactic.CC.CCState.foldEqc {α} (s : Mathlib.Tactic.CC.CCState) (e : expr) (a : α)
    (f : α → expr → α) : α :=
  Mathlib.Tactic.CC.CCState.foldEqcCore s f e e a
#align cc_state.fold_eqc Mathlib.Tactic.CC.CCState.foldEqc
-/

#print Mathlib.Tactic.CC.CCState.foldEqcM /-
unsafe def Mathlib.Tactic.CC.CCState.foldEqcM {α} {m : Type → Type} [Monad m]
    (s : Mathlib.Tactic.CC.CCState) (e : expr) (a : α) (f : α → expr → m α) : m α :=
  Mathlib.Tactic.CC.CCState.foldEqc s e (return a) fun act e => do
    let a ← act
    f a e
#align cc_state.mfold_eqc Mathlib.Tactic.CC.CCState.foldEqcM
-/

end Mathlib.Tactic.CC.CCState

open Tactic

#print Lean.MVarId.cc /-
unsafe def Lean.MVarId.cc (cfg : Mathlib.Tactic.CC.CCConfig) : tactic Unit := do
  intros
  let s ← Mathlib.Tactic.CC.CCState.mkUsingHsCore cfg
  let t ← target
  let s ← s.internalize t
  if s then do
      let pr ← s
      mk_app `false.elim [t, pr] >>= exact
    else do
      let tr ← return <| expr.const `true []
      let b ← s t tr
      if b then do
          let pr ← s t tr
          mk_app `of_eq_true [pr] >>= exact
        else do
          let dbg ← get_bool_option `trace.cc.failure ff
          if dbg then do
              let ccf ← pp s
              fail
                  f! "cc tactic failed, equivalence classes: 
                    {ccf}"
            else do
              fail "cc tactic failed"
#align tactic.cc_core Lean.MVarId.cc
-/

/- warning: tactic.cc clashes with tactic.cc_core -> Lean.MVarId.cc
Case conversion may be inaccurate. Consider using '#align tactic.cc Lean.MVarId.ccₓ'. -/
#print Lean.MVarId.cc /-
unsafe def Lean.MVarId.cc : tactic Unit :=
  Lean.MVarId.cc { }
#align tactic.cc Lean.MVarId.cc
-/

/- warning: tactic.cc_dbg_core clashes with tactic.cc_core -> Lean.MVarId.cc
Case conversion may be inaccurate. Consider using '#align tactic.cc_dbg_core Lean.MVarId.ccₓ'. -/
#print Lean.MVarId.cc /-
unsafe def Lean.MVarId.cc (cfg : Mathlib.Tactic.CC.CCConfig) : tactic Unit :=
  save_options <| set_bool_option `trace.cc.failure true >> Lean.MVarId.cc cfg
#align tactic.cc_dbg_core Lean.MVarId.cc
-/

/- warning: tactic.cc_dbg clashes with tactic.cc_core -> Lean.MVarId.cc
Case conversion may be inaccurate. Consider using '#align tactic.cc_dbg Lean.MVarId.ccₓ'. -/
#print Lean.MVarId.cc /-
unsafe def Lean.MVarId.cc : tactic Unit :=
  Lean.MVarId.cc { }
#align tactic.cc_dbg Lean.MVarId.cc
-/

#print Lean.Meta.AC.acRflTactic /-
unsafe def Lean.Meta.AC.acRflTactic : tactic Unit := do
  let (lhs, rhs) ← target >>= match_eq
  let s ← return <| Mathlib.Tactic.CC.CCState.mk
  let s ← s.internalize lhs
  let s ← s.internalize rhs
  let b ← s.is_eqv lhs rhs
  if b then do
      s lhs rhs >>= exact
    else do
      fail "ac_refl failed"
#align tactic.ac_refl Lean.Meta.AC.acRflTactic
-/

